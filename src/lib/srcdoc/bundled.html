<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<style>
			* {
				margin: 0;
				padding: 0;
				/*  include padding and the border */
				box-sizing: border-box;
				/* more padding on the inside of your box, but you don't want the box to resize */
				/* box-sizing: content-box; */
			}

			body {
				margin: 0;
				position: relative;
			}
		</style>
		<script defer type="module">
			var app=function(){"use strict";function e(){}function t(e){return e()}function n(){return Object.create(null)}function o(e){e.forEach(t)}function s(e){return"function"==typeof e}function r(e,t){return e!=e?t==t:e!==t||e&&"object"==typeof e||"function"==typeof e}function c(e,t,n){e.insertBefore(t,n||null)}function i(e){e.parentNode.removeChild(e)}function u(e){return document.createElement(e)}function a(e){return document.createTextNode(e)}function l(){return a("")}function p(e,t,{bubbles:n=!1,cancelable:o=!1}){const s=document.createEvent("CustomEvent");return s.initCustomEvent(e,n,o,t),s}class d{constructor(e=!1){this.is_svg=!1,this.is_svg=e,this.e=this.n=null}c(e){this.h(e)}m(e,t,n=null){var o;this.e||(this.is_svg?this.e=(o=t.nodeName,document.createElementNS("http://www.w3.org/2000/svg",o)):this.e=u(t.nodeName),this.t=t,this.c(e)),this.i(n)}h(e){this.e.innerHTML=e,this.n=Array.from(this.e.childNodes)}i(e){for(let t=0;t<this.n.length;t+=1)c(this.t,this.n[t],e)}p(e){this.d(),this.h(e),this.i(this.a)}d(){this.n.forEach(i)}}let f;function h(e){f=e}function m(){if(!f)throw new Error("Function called outside component initialization");return f}function $(e){m().$$.on_mount.push(e)}function g(e){m().$$.on_destroy.push(e)}function w(){const e=m();return(t,n,{cancelable:o=!1}={})=>{const s=e.$$.callbacks[t];if(s){const r=p(t,n,{cancelable:o});return s.slice().forEach((t=>{t.call(e,r)})),!r.defaultPrevented}return!0}}const y=[],b=[],v=[],M=[],_=Promise.resolve();let E=!1;function x(e){v.push(e)}const k=new Set;let j=0;function C(){const e=f;do{for(;j<y.length;){const e=y[j];j++,h(e),O(e.$$)}for(h(null),y.length=0,j=0;b.length;)b.pop()();for(let e=0;e<v.length;e+=1){const t=v[e];k.has(t)||(k.add(t),t())}v.length=0}while(y.length);for(;M.length;)M.pop()();E=!1,k.clear(),h(e)}function O(e){if(null!==e.fragment){e.update(),o(e.before_update);const t=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,t),e.after_update.forEach(x)}}const R=new Set;let S;function P(e,t){e&&e.i&&(R.delete(e),e.i(t))}function L(e,t,n,o){if(e&&e.o){if(R.has(e))return;R.add(e),S.c.push((()=>{R.delete(e),o&&(n&&e.d(1),o())})),e.o(t)}else o&&o()}const N="undefined"!=typeof window?window:"undefined"!=typeof globalThis?globalThis:global;function T(e,n,r,c){const{fragment:i,on_mount:u,on_destroy:a,after_update:l}=e.$$;i&&i.m(n,r),c||x((()=>{const n=u.map(t).filter(s);a?a.push(...n):o(n),e.$$.on_mount=[]})),l.forEach(x)}function D(e,t){const n=e.$$;null!==n.fragment&&(o(n.on_destroy),n.fragment&&n.fragment.d(t),n.on_destroy=n.fragment=null,n.ctx=[])}function H(e,t){-1===e.$$.dirty[0]&&(y.push(e),E||(E=!0,_.then(C)),e.$$.dirty.fill(0)),e.$$.dirty[t/31|0]|=1<<t%31}function U(t,s,r,c,u,a,l,p=[-1]){const d=f;h(t);const m=t.$$={fragment:null,ctx:null,props:a,update:e,not_equal:u,bound:n(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(s.context||(d?d.$$.context:[])),callbacks:n(),dirty:p,skip_bound:!1,root:s.target||d.$$.root};l&&l(m.root);let $=!1;if(m.ctx=r?r(t,s.props||{},((e,n,...o)=>{const s=o.length?o[0]:n;return m.ctx&&u(m.ctx[e],m.ctx[e]=s)&&(!m.skip_bound&&m.bound[e]&&m.bound[e](s),$&&H(t,e)),n})):[],m.update(),$=!0,o(m.before_update),m.fragment=!!c&&c(m.ctx),s.target){if(s.hydrate){const e=function(e){return Array.from(e.childNodes)}(s.target);m.fragment&&m.fragment.l(e),e.forEach(i)}else m.fragment&&m.fragment.c();s.intro&&P(t.$$.fragment),T(t,s.target,s.anchor,s.customElement),C()}h(d)}function B(e,t){document.dispatchEvent(p(e,Object.assign({version:"3.49.0"},t),{bubbles:!0}))}function I(e,t,n){B("SvelteDOMInsert",{target:e,node:t,anchor:n}),c(e,t,n)}function A(e){B("SvelteDOMRemove",{node:e}),i(e)}function q(e,t,n){for(const o of Object.keys(t))~n.indexOf(o)||console.warn(`<${e}> received an unexpected slot "${o}".`)}class X extends class{$destroy(){D(this,1),this.$destroy=e}$on(e,t){const n=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return n.push(t),()=>{const e=n.indexOf(t);-1!==e&&n.splice(e,1)}}$set(e){var t;this.$$set&&(t=e,0!==Object.keys(t).length)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}{constructor(e){if(!e||!e.target&&!e.$$inline)throw new Error("'target' is a required option");super()}$destroy(){super.$destroy(),this.$destroy=()=>{console.warn("Component was already destroyed")}}$capture_state(){}$inject_state(){}}const{Object:z}=N;function F(t){let n,o,s,r;const c={c:function(){n=new d(!1),o=l(),s=a(" "),r=u("div"),n.a=o,function(e,t,n,o,s){e.__svelte_meta={loc:{file:t,line:n,column:o,char:s}}}(r,"src\\lib\\ComponentMounter.svelte",79,0,2106)},l:function(e){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(e,c){n.m(t[0],document.head),function(e,t){B("SvelteDOMInsert",{target:e,node:t}),function(e,t){e.appendChild(t)}(e,t)}(document.head,o),I(e,s,c),I(e,r,c),t[6](r)},p:function(e,[t]){1&t&&n.p(e[0])},i:e,o:e,d:function(e){A(o),e&&n.d(),e&&A(s),e&&A(r),t[6](null)}};return B("SvelteRegisterBlock",{block:c,id:F.name,type:"component",source:"",ctx:t}),c}function W(e,t,n){let{$$slots:o={},$$scope:s}=t;q("ComponentMounter",o,[]);let{esModule:r}=t,{props:c}=t,{css:i}=t;const u=w();let a,l,p,d;async function f(){n(0,i=i?`<style>${i}</style>`:""),a&&(a.$destroy(),URL.revokeObjectURL(l));const e=new Blob([r],{type:"text/javascript"});l=URL.createObjectURL(e);const t=(await import(l)).default;if(!t||!p)return;n(1,p.innerHTML="",p),n(4,a=new t({target:p,props:{}}));const o=a.$$.props;let s={};Object.keys(o).map((e=>{s[e]=a[e]}));let d=Object.assign(s,c);u("change",d),a.$on("change",(e=>{u("change",e.detail)})),h(d)}function h(e){a&&e&&a.$set({...e})}$((()=>{n(5,d=!0)})),g((()=>{a&&a.$destroy(),l&&URL.revokeObjectURL(l)}));const m=["esModule","props","css"];return z.keys(t).forEach((e=>{~m.indexOf(e)||"$$"===e.slice(0,2)||"slot"===e||console.warn(`<ComponentMounter> was created with unknown prop '${e}'`)})),e.$$set=e=>{"esModule"in e&&n(2,r=e.esModule),"props"in e&&n(3,c=e.props),"css"in e&&n(0,i=e.css)},e.$capture_state=()=>({onMount:$,onDestroy:g,createEventDispatcher:w,esModule:r,props:c,css:i,dispatch:u,component:a,url:l,target:p,mounted:d,loadEsModuleComponent:f,setProps:h}),e.$inject_state=e=>{"esModule"in e&&n(2,r=e.esModule),"props"in e&&n(3,c=e.props),"css"in e&&n(0,i=e.css),"component"in e&&n(4,a=e.component),"url"in e&&(l=e.url),"target"in e&&n(1,p=e.target),"mounted"in e&&n(5,d=e.mounted)},t&&"$$inject"in t&&e.$inject_state(t.$$inject),e.$$.update=()=>{36&e.$$.dirty&&d&&r&&f(),24&e.$$.dirty&&a&&c&&h()},[i,p,r,c,a,d,function(e){b[e?"unshift":"push"]((()=>{p=e,n(1,p)}))}]}class G extends X{constructor(e){super(e),U(this,e,W,F,r,{esModule:2,props:3,css:0}),B("SvelteRegisterComponent",{component:this,tagName:"ComponentMounter",options:e,id:F.name});const{ctx:t}=this.$$,n=e.props||{};void 0!==t[2]||"esModule"in n||console.warn("<ComponentMounter> was created without expected prop 'esModule'"),void 0!==t[3]||"props"in n||console.warn("<ComponentMounter> was created without expected prop 'props'"),void 0!==t[0]||"css"in n||console.warn("<ComponentMounter> was created without expected prop 'css'")}get esModule(){throw new Error("<ComponentMounter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set esModule(e){throw new Error("<ComponentMounter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get props(){throw new Error("<ComponentMounter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set props(e){throw new Error("<ComponentMounter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get css(){throw new Error("<ComponentMounter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set css(e){throw new Error("<ComponentMounter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}function J(e){let t,n;t=new G({props:{esModule:e[0],props:e[1]},$$inline:!0}),t.$on("change",e[3]);const o={c:function(){!function(e){e&&e.c()}(t.$$.fragment)},m:function(e,o){T(t,e,o),n=!0},p:function(e,n){const o={};1&n&&(o.esModule=e[0]),2&n&&(o.props=e[1]),t.$set(o)},i:function(e){n||(P(t.$$.fragment,e),n=!0)},o:function(e){L(t.$$.fragment,e),n=!1},d:function(e){D(t,e)}};return B("SvelteRegisterBlock",{block:o,id:J.name,type:"if",source:"(31:0) {#if esModule}",ctx:e}),o}function K(e){let t,n,s,r,c=e[0]&&J(e);const i={c:function(){c&&c.c(),t=l()},l:function(e){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(o,i){c&&c.m(o,i),I(o,t,i),n=!0,s||(r=function(e,t,n,o,s,r){const c=!0===o?["capture"]:o?Array.from(Object.keys(o)):[];s&&c.push("preventDefault"),r&&c.push("stopPropagation"),B("SvelteDOMAddEventListener",{node:e,event:t,handler:n,modifiers:c});const i=function(e,t,n,o){return e.addEventListener(t,n,o),()=>e.removeEventListener(t,n,o)}(e,t,n,o);return()=>{B("SvelteDOMRemoveEventListener",{node:e,event:t,handler:n,modifiers:c}),i()}}(window,"message",e[2],!1,!1,!1),s=!0)},p:function(e,[n]){e[0]?c?(c.p(e,n),1&n&&P(c,1)):(c=J(e),c.c(),P(c,1),c.m(t.parentNode,t)):c&&(S={r:0,c:[],p:S},L(c,1,1,(()=>{c=null})),S.r||o(S.c),S=S.p)},i:function(e){n||(P(c),n=!0)},o:function(e){L(c),n=!1},d:function(e){c&&c.d(e),e&&A(t),s=!1,r()}};return B("SvelteRegisterBlock",{block:i,id:K.name,type:"component",source:"",ctx:e}),i}function Q(e,t,n){let o,s,r,{$$slots:c={},$$scope:i}=t;async function u(e){e?.data&&(e?.data.hasOwnProperty("load")&&(n(0,({esModule:o,props:s}=e.data.load),o,n(1,s)),r=t=>{e.ports[0].postMessage(t)}),e?.data.hasOwnProperty("setProps")&&n(1,s=e.data.setProps))}function a(e){r&&e.detail&&r(e.detail)}q("InnerHandler",c,[]);const l=[];return Object.keys(t).forEach((e=>{~l.indexOf(e)||"$$"===e.slice(0,2)||"slot"===e||console.warn(`<InnerHandler> was created with unknown prop '${e}'`)})),e.$capture_state=()=>({ComponentMounter:G,esModule:o,props:s,reply:r,handleMessage:u,handleChange:a}),e.$inject_state=e=>{"esModule"in e&&n(0,o=e.esModule),"props"in e&&n(1,s=e.props),"reply"in e&&(r=e.reply)},t&&"$$inject"in t&&e.$inject_state(t.$$inject),[o,s,u,a]}globalThis.fetch=()=>(console.log("Nulled out fetch"),{json:()=>({result:"no fetch, sorry"})}),globalThis.XMLHttpRequest=class{constructor(){console.log("Nulled out XHR too")}open=()=>null;send=()=>null},globalThis.WebSocket=null,globalThis.EventSource=null;return new class extends X{constructor(e){super(e),U(this,e,Q,K,r,{}),B("SvelteRegisterComponent",{component:this,tagName:"InnerHandler",options:e,id:K.name})}}({target:document.body,props:{}})}();

		</script>
	</head>

	<body></body>
</html>
