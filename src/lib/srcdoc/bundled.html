<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />

		<script defer type="module">
			var app=function(){"use strict";function e(){}function t(e){return e()}function n(){return Object.create(null)}function o(e){e.forEach(t)}function r(e){return"function"==typeof e}function i(e,t){return e!=e?t==t:e!==t||e&&"object"==typeof e||"function"==typeof e}function s(e){e.parentNode.removeChild(e)}function c(e){return document.createElement(e)}function a(e,t,n,o){return e.addEventListener(t,n,o),()=>e.removeEventListener(t,n,o)}let d,l;function u(){if(void 0===d){d=!1;try{"undefined"!=typeof window&&window.parent&&window.parent.document}catch(e){d=!0}}return d}function f(e){l=e}function p(e){(function(){if(!l)throw new Error("Function called outside component initialization");return l})().$$.on_mount.push(e)}const g=[],m=[],h=[],y=[],$=Promise.resolve();let w=!1;function v(e){h.push(e)}const b=new Set;let E=0;function k(){const e=l;do{for(;E<g.length;){const e=g[E];E++,f(e),C(e.$$)}for(f(null),g.length=0,E=0;m.length;)m.pop()();for(let e=0;e<h.length;e+=1){const t=h[e];b.has(t)||(b.add(t),t())}h.length=0}while(g.length);for(;y.length;)y.pop()();w=!1,b.clear(),f(e)}function C(e){if(null!==e.fragment){e.update(),o(e.before_update);const t=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,t),e.after_update.forEach(v)}}const R=new Set;function x(e,t){-1===e.$$.dirty[0]&&(g.push(e),w||(w=!0,$.then(k)),e.$$.dirty.fill(0)),e.$$.dirty[t/31|0]|=1<<t%31}function S(i,c,a,d,u,p,g,m=[-1]){const h=l;f(i);const y=i.$$={fragment:null,ctx:null,props:p,update:e,not_equal:u,bound:n(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(c.context||(h?h.$$.context:[])),callbacks:n(),dirty:m,skip_bound:!1,root:c.target||h.$$.root};g&&g(y.root);let $=!1;if(y.ctx=a?a(i,c.props||{},((e,t,...n)=>{const o=n.length?n[0]:t;return y.ctx&&u(y.ctx[e],y.ctx[e]=o)&&(!y.skip_bound&&y.bound[e]&&y.bound[e](o),$&&x(i,e)),t})):[],y.update(),$=!0,o(y.before_update),y.fragment=!!d&&d(y.ctx),c.target){if(c.hydrate){const e=function(e){return Array.from(e.childNodes)}(c.target);y.fragment&&y.fragment.l(e),e.forEach(s)}else y.fragment&&y.fragment.c();c.intro&&((w=i.$$.fragment)&&w.i&&(R.delete(w),w.i(b))),function(e,n,i,s){const{fragment:c,on_mount:a,on_destroy:d,after_update:l}=e.$$;c&&c.m(n,i),s||v((()=>{const n=a.map(t).filter(r);d?d.push(...n):o(n),e.$$.on_mount=[]})),l.forEach(v)}(i,c.target,c.anchor,c.customElement),k()}var w,b;f(h)}var _,j,M,L,A;!function(e){e.Call="call",e.Reply="reply",e.Syn="syn",e.SynAck="synAck",e.Ack="ack"}(_||(_={})),function(e){e.Fulfilled="fulfilled",e.Rejected="rejected"}(j||(j={})),function(e){e.ConnectionDestroyed="ConnectionDestroyed",e.ConnectionTimeout="ConnectionTimeout",e.NoIframeSrc="NoIframeSrc"}(M||(M={})),function(e){e.DataCloneError="DataCloneError"}(L||(L={})),function(e){e.Message="message"}(A||(A={}));const N=({name:e,message:t,stack:n})=>({name:e,message:t,stack:n});let O=0;var D=()=>++O;const F=e=>e?e.split("."):[],H=(e,t,n)=>{const o=F(t);return o.reduce(((e,t,r)=>(void 0===e[t]&&(e[t]={}),r===o.length-1&&(e[t]=n),e[t])),e),e},I=(e,t)=>{const n={};return Object.keys(e).forEach((o=>{const r=e[o],i=((e,t)=>{const n=F(t||"");return n.push(e),(e=>e.join("."))(n)})(o,t);"object"==typeof r&&Object.assign(n,I(r,i)),"function"==typeof r&&(n[i]=r)})),n};var U=(e,t,n,o,r)=>{const{localName:i,local:s,remote:c,originForSending:a,originForReceiving:d}=t;let l=!1;r(`${i}: Connecting call sender`);const u=e=>(...t)=>{let n;r(`${i}: Sending ${e}() call`);try{c.closed&&(n=!0)}catch(e){n=!0}if(n&&o(),l){const t=new Error(`Unable to send ${e}() call due to destroyed connection`);throw t.code=M.ConnectionDestroyed,t}return new Promise(((n,o)=>{const l=D(),u=t=>{if(t.source!==c||t.data.penpal!==_.Reply||t.data.id!==l)return;if("*"!==d&&t.origin!==d)return void r(`${i} received message from origin ${t.origin} which did not match expected origin ${d}`);const a=t.data;r(`${i}: Received ${e}() reply`),s.removeEventListener(A.Message,u);let f=a.returnValue;a.returnValueIsError&&(f=(e=>{const t=new Error;return Object.keys(e).forEach((n=>t[n]=e[n])),t})(f)),(a.resolution===j.Fulfilled?n:o)(f)};s.addEventListener(A.Message,u);const f={penpal:_.Call,id:l,methodName:e,args:t};c.postMessage(f,a)}))},f=n.reduce(((e,t)=>(e[t]=u(t),e)),{});return Object.assign(e,(e=>{const t={};for(const n in e)H(t,n,e[n]);return t})(f)),()=>{l=!0}},W=(e,t,n,o)=>{const{destroy:r,onDestroy:i}=n;return n=>{if(!(e instanceof RegExp?e.test(n.origin):"*"===e||e===n.origin))return void o(`Child: Handshake - Received SYN-ACK from origin ${n.origin} which did not match expected origin ${e}`);o("Child: Handshake - Received SYN-ACK, responding with ACK");const s="null"===n.origin?"*":n.origin,c={penpal:_.Ack,methodNames:Object.keys(t)};window.parent.postMessage(c,s);const a={localName:"Child",local:window,remote:window.parent,originForSending:s,originForReceiving:n.origin},d=((e,t,n)=>{const{localName:o,local:r,remote:i,originForSending:s,originForReceiving:c}=e;let a=!1;const d=e=>{if(e.source!==i||e.data.penpal!==_.Call)return;if("*"!==c&&e.origin!==c)return void n(`${o} received message from origin ${e.origin} which did not match expected origin ${c}`);const r=e.data,{methodName:d,args:l,id:u}=r;n(`${o}: Received ${d}() call`);const f=e=>t=>{if(n(`${o}: Sending ${d}() reply`),a)return void n(`${o}: Unable to send ${d}() reply due to destroyed connection`);const r={penpal:_.Reply,id:u,resolution:e,returnValue:t};e===j.Rejected&&t instanceof Error&&(r.returnValue=N(t),r.returnValueIsError=!0);try{i.postMessage(r,s)}catch(e){if(e.name===L.DataCloneError){const t={penpal:_.Reply,id:u,resolution:j.Rejected,returnValue:N(e),returnValueIsError:!0};i.postMessage(t,s)}throw e}};new Promise((e=>e(t[d].apply(t,l)))).then(f(j.Fulfilled),f(j.Rejected))};return r.addEventListener(A.Message,d),()=>{a=!0,r.removeEventListener(A.Message,d)}})(a,t,o);i(d);const l={},u=U(l,a,n.data.methodNames,r,o);return i(u),l}};var T=(e={})=>{const{parentOrigin:t="*",methods:n={},timeout:o,debug:r=!1}=e,i=(e=>(...t)=>{e&&console.log("[Penpal]",...t)})(r),s=((e,t)=>{const n=[];let o=!1;return{destroy(r){o||(o=!0,t(`${e}: Destroying connection`),n.forEach((e=>{e(r)})))},onDestroy(e){o?e():n.push(e)}}})("Child",i),{destroy:c,onDestroy:a}=s,d=I(n),l=W(t,d,s,i),u=new Promise(((e,n)=>{const r=((e,t)=>{let n;return void 0!==e&&(n=window.setTimeout((()=>{const n=new Error(`Connection timed out after ${e}ms`);n.code=M.ConnectionTimeout,t(n)}),e)),()=>{clearTimeout(n)}})(o,c),s=t=>{if((()=>{try{clearTimeout()}catch(e){return!1}return!0})()&&t.source===parent&&t.data&&t.data.penpal===_.SynAck){const n=l(t);n&&(window.removeEventListener(A.Message,s),r(),e(n))}};window.addEventListener(A.Message,s),(()=>{i("Child: Handshake - Sending SYN");const e={penpal:_.Syn},n=t instanceof RegExp?"*":t;window.parent.postMessage(e,n)})(),a((e=>{window.removeEventListener(A.Message,s),e&&n(e)}))}));return{promise:u,destroy(){c()}}};function V(t){let n,o;return{c(){var e,o,r;n=c("div"),e=n,o="id",null==(r="app")?e.removeAttribute(o):e.getAttribute(o)!==r&&e.setAttribute(o,r),v((()=>t[2].call(n)))},m(e,r){!function(e,t,n){e.insertBefore(t,n||null)}(e,n,r),o=function(e,t){"static"===getComputedStyle(e).position&&(e.style.position="relative");const n=c("iframe");n.setAttribute("style","display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;"),n.setAttribute("aria-hidden","true"),n.tabIndex=-1;const o=u();let r;return o?(n.src="data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>",r=a(window,"message",(e=>{e.source===n.contentWindow&&t()}))):(n.src="about:blank",n.onload=()=>{r=a(n.contentWindow,"resize",t)}),function(e,t){e.appendChild(t)}(e,n),()=>{(o||r&&n.contentWindow)&&r(),s(n)}}(n,t[2].bind(n))},p:e,i:e,o:e,d(e){e&&s(n),o()}}}function P(e,t,n){let o,r,i,{offsetWidth:s}=t,{offsetHeight:c}=t;async function a({esModule:e,props:t}){const n=new Blob([e],{type:"text/javascript"});i=URL.createObjectURL(n),import(i).then((function({default:e}){e&&(o&&o.$destroy(),document.getElementById("app").innerHTML="",o=new e({target:document.getElementById("app")||document.body,props:{...t}}),o.$on("change",(e=>{console.log("change",e),r.updateProps(e.detail)})),URL.revokeObjectURL(i),r.setSerializedSource())}))}return p((async()=>{const e=T({methods:{loadEsModuleComponent:a}});return r=await e.promise,()=>{o&&o.$destroy(),i&&URL.revokeObjectURL(i)}})),e.$$set=e=>{"offsetWidth"in e&&n(0,s=e.offsetWidth),"offsetHeight"in e&&n(1,c=e.offsetHeight)},[s,c,function(){s=this.offsetWidth,c=this.offsetHeight,n(0,s),n(1,c)}]}return new class extends class{$destroy(){!function(e,t){const n=e.$$;null!==n.fragment&&(o(n.on_destroy),n.fragment&&n.fragment.d(t),n.on_destroy=n.fragment=null,n.ctx=[])}(this,1),this.$destroy=e}$on(e,t){const n=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return n.push(t),()=>{const e=n.indexOf(t);-1!==e&&n.splice(e,1)}}$set(e){var t;this.$$set&&(t=e,0!==Object.keys(t).length)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}{constructor(e){super(),S(this,e,P,V,i,{offsetWidth:0,offsetHeight:1})}}({target:document.body,props:{}})}();

		</script>
	</head>

	<body></body>
</html>
